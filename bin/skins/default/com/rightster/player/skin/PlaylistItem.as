package com.rightster.player.skin {	import com.gskinner.motion.GTweener;	import com.rightster.player.controller.IController;	import com.rightster.player.model.ErrorCode;	import com.rightster.player.model.MetaVideo;	import com.rightster.player.view.IColors;	import flash.display.JointStyle;	import flash.display.Loader;	import flash.display.Sprite;	import flash.events.AsyncErrorEvent;	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.events.MouseEvent;	import flash.events.SecurityErrorEvent;	import flash.net.URLRequest;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.text.TextFormat;	/**	 * @author KJR	 */	public class PlaylistItem extends Sprite {		public static const WIDTH : Number = 146;		public static const HEIGHT : Number = 83;				private const ELLIPSIS : String = "\u2026";		private const PADDING : Number = 5;		private const STROKE_SIZE : Number = 1;		private const BORDER_SIZE : Number = 4;		private const FADE_IN_TIME : Number = 0.2;		private var controller : IController;		private var colorScheme : IColors;		private var metaVideo : MetaVideo;		private var strTitle : String = "";		private var bg : Sprite;		private var outline : Sprite;		private var border : Sprite;		private var tf : TextField;		private var loader : Loader;		private var request : URLRequest;		private var loaded : Boolean;		private var _selected : Boolean;		private var _width : Number;		private var _height : Number;		private var fallbackIsDirty : Boolean = false;		public function PlaylistItem(controller : IController) {			this.controller = controller;			this.colorScheme = controller.colors;			commitProperties();			createChildren();			draw();			layout();			hideInfo();			registerEventListeners();			setStyle();			this.selected = false;			this.loaded = false;		}		/*		 * PUBLIC METHODS		 */		public function load(metaVideo : MetaVideo) : void {			// Log.write("PlaylistItem.load");			this.metaVideo = metaVideo;			strTitle = metaVideo.title;			if (!loaded) {				request = new URLRequest(metaVideo.thumbnailImageUrl);				// Log.write("PlaylistItem.load * URL: " + request.url, Log.NET);				try {					loader.load(request);				} catch (err : Error) {					controller.error(ErrorCode.PLUGIN_CUSTOM_ERROR, "PlaylistItem.load * " + err.message);					fallback();				}				loaded = true;			}			layout();			if (this.metaVideo.playlistIndex == controller.getPlaylist().currentIndex) {				this.selected = true;			}		}		public function clear() : void {			if (loaded) {				loader.unloadAndStop(true);			}			metaVideo = null;			strTitle = "";			loaded = false;			_selected = false;			fallbackIsDirty = false;		}		public function dispose() : void {			// Log.write("PlaylistItem.dispose");			unregisterEventListeners();			loader.unloadAndStop(true);			removeAllChildren();			metaVideo = null;			controller = null;			colorScheme = null;		}		/*		 * GETTERS SETTERS		 */		override public function get width() : Number {			return _width ;		}		override public function set width(value : Number) : void {			_width = value;			layout();		}		override public function get height() : Number {			return _height ;		}		override public function set height(value : Number) : void {			_height = value;			layout();		}		public function get selected() : Boolean {			return _selected;		}		public function set selected(value : Boolean) : void {			_selected = value;			showSelectedState(_selected);		}		/*		 * EVENT HANDLERS		 */		private function completeHandler(event : Event) : void {			loader.width = WIDTH;			loader.height = HEIGHT;			loader.alpha = 0;			GTweener.to(loader, FADE_IN_TIME, {alpha:1});		}		private function onClick(event : MouseEvent) : void {			try {				if (!this.selected) {					// IMPORTANT: order- invoke play before close event dispatched					var index : int = metaVideo.playlistIndex;					controller.playVideoAt(index);					controller.dispatchEvent(new PlaylistViewEvent(PlaylistViewEvent.HIDE));				}			} catch(error : TypeError) {				// silent			}		}		private function onMouseOver(event : MouseEvent) : void {			if (!fallbackIsDirty) {				showInfo();			}			border.visible = true;			border.transform.colorTransform = colorScheme.highlightCT;		}		private function onMouseOut(event : MouseEvent) : void {			if (!fallbackIsDirty) {				hideInfo();			}			border.transform.colorTransform = colorScheme.selectedCT;			showSelectedState(_selected);		}		private function errorHandler(event : Event) : void {			controller.error(ErrorCode.PLUGIN_CUSTOM_ERROR, "PlaylistItem.errorHandler * " + event['text']);			fallback();		}		/*		 * PRIVATE METHODS		 */		private function commitProperties() : void {			_width = WIDTH;			_height = HEIGHT;			mouseChildren = false;			buttonMode = true;			useHandCursor = true;		}		private function createChildren() : void {			bg = new Sprite();			addChild(bg);			var tFormat : TextFormat = new TextFormat();			tFormat.font = Constants.FONT_NAME;			tFormat.size = Constants.FONT_SIZE_LARGE;			tf = new TextField();			tf.defaultTextFormat = tFormat;			tf.multiline = true;			tf.wordWrap = true;			tf.embedFonts = false;			tf.selectable = false;			addChild(tf);			loader = new Loader();			addChild(loader);			outline = new Sprite();			addChild(outline);			border = new Sprite();			addChild(border);		}		private function removeAllChildren() : void {			if (numChildren > 0) {				removeChildren(0, numChildren - 1);			}		}		private function draw() : void {			var offset : int = 0;			with(bg.graphics) {				clear();				beginFill(0xff0000, 1);				drawRect(0, 0, this.width, this.height);				endFill();			}			with(outline.graphics) {				clear();				lineStyle(STROKE_SIZE, 0x0000FF, 1, true, "normal", null, JointStyle.MITER);				drawRect(offset, offset, this.width - (offset * 2), this.height - (offset * 2));			}			with(border.graphics) {				clear();				lineStyle(BORDER_SIZE, 0x0000FF, 1, true, "normal", null, JointStyle.MITER);				drawRect(offset, offset, this.width - (offset * 2), this.height - (offset * 2));			}		}		private function layout() : void {			tf.x = PADDING + BORDER_SIZE;			tf.y = PADDING + BORDER_SIZE;			tf.width = this.width - ((PADDING + BORDER_SIZE) * 2);			tf.height = this.height - ((PADDING + BORDER_SIZE) * 2);			tf.text = strTitle;			assertTextFieldMaxHeight();		}		private function assertTextFieldMaxHeight() : void {			var maxHeight : Number = this.height - (PADDING + BORDER_SIZE * 2);			var str : String = strTitle;			tf.text = str;			while (tf.textHeight > maxHeight) {				// Log.write(maxHeight);				// Log.write(tf.textHeight);				var len : int = str.length;				str = str.substr(0, len - 3) + ELLIPSIS;				tf.text = str;				tf.autoSize = TextFieldAutoSize.LEFT;			}		}		private function registerEventListeners() : void {			addEventListener(MouseEvent.CLICK, onClick);			addEventListener(MouseEvent.MOUSE_OVER, onMouseOver);			addEventListener(MouseEvent.MOUSE_OUT, onMouseOut);			loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);			loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);			loader.contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR, errorHandler);			loader.contentLoaderInfo.addEventListener(AsyncErrorEvent.ASYNC_ERROR, errorHandler);		}		private function unregisterEventListeners() : void {			removeEventListener(MouseEvent.CLICK, onClick);			loader.contentLoaderInfo.removeEventListener(Event.COMPLETE, completeHandler);			loader.contentLoaderInfo.removeEventListener(IOErrorEvent.IO_ERROR, errorHandler);			loader.contentLoaderInfo.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, errorHandler);			loader.contentLoaderInfo.removeEventListener(AsyncErrorEvent.ASYNC_ERROR, errorHandler);			removeEventListener(MouseEvent.MOUSE_OVER, onMouseOver);			removeEventListener(MouseEvent.MOUSE_OUT, onMouseOut);		}		private function setStyle() : void {			bg.transform.colorTransform = colorScheme.backgroundCT;			outline.transform.colorTransform = colorScheme.backgroundCT;			border.transform.colorTransform = colorScheme.selectedCT;			tf.transform.colorTransform = colorScheme.primaryCT;		}		private function showSelectedState(value : Boolean) : void {			border.visible = value;		}		private function showInfo() : void {			tf.visible = true;			loader.visible = false;		}		private function hideInfo() : void {			tf.visible = false;			loader.visible = true;		}		private function fallback() : void {			showInfo();			GTweener.to(loader, FADE_IN_TIME, {alpha:1});			fallbackIsDirty = true;		}	}}